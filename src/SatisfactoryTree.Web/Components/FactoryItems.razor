@using SatisfactoryTree.Logic.Models
@using SatisfactoryTree.Web.Services
@using SatisfactoryTree.Logic.Abstractions
@using SatisfactoryTree.Logic.Services
@inject SatisfactoryTree.Logic.Abstractions.IFactoryItemDisplayService DisplayService
@inject PlanService PlanService
@inject PartLookupService PartLookupService
@implements IDisposable
@using System.Linq

@code {
	[Parameter]
	public Factory? Factory { get; set; }
	[Parameter]
	public FactoryCatalog FactoryCatalog { get; set; } = new();

	private bool isAddingExportedPart = false;
	private LookupItem? selectedPartToExport = null; // only for the add-export UI
	private double exportedQuantity = 1.0;
	private Dictionary<string, string>? _partsDisplayLookup; // id -> display name cache
	private List<LookupItem> availableRecipes = new(); // recipes for the selected part
	private LookupItem? selectedRecipeToExport = null; // selected recipe for export

	protected override void OnInitialized()
	{
		PlanService.PlanChanged += OnPlanChanged;
	}

	protected override void OnParametersSet()
	{
		// Use PartLookupService to ensure lookup and cache display names
		try
		{
			PartLookupService.EnsurePartsLookup(FactoryCatalog);
			if (_partsDisplayLookup == null)
			{
				_partsDisplayLookup = PartLookupService.BuildDisplayLookup(FactoryCatalog);
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine($"FactoryItems: Failed initializing lookups: {ex.Message}");
		}
	}

	private string GetPartDisplayName(string partCode)
	{
		if (string.IsNullOrWhiteSpace(partCode))
		{
			return partCode;
		}
		if (_partsDisplayLookup != null && _partsDisplayLookup.TryGetValue(partCode, out string? display))
		{
			return display;
		}
		return PartLookupService.GetPartDisplayName(FactoryCatalog, partCode, _partsDisplayLookup);
	}

	private void OnPlanChanged() => InvokeAsync(StateHasChanged);

	public void Dispose() => PlanService.PlanChanged -= OnPlanChanged;

	private LookupItem? GetCurrentLookup(Item item)
	{
		return PartLookupService.GetCurrentLookup(item, FactoryCatalog);
	}

	private List<LookupItem> GetRecipesForPart(string partName)
	{
		if (FactoryCatalog == null || string.IsNullOrEmpty(partName))
		{
			return new List<LookupItem>();
		}
		
		List<Recipe> recipes = SatisfactoryTree.Logic.Calculations.Lookups.GetRecipes(FactoryCatalog, partName);
		return recipes.Select(r => new LookupItem(r.Name, r.DisplayName)).ToList();
	}

	private LookupItem? GetCurrentRecipeLookup(Item item)
	{
		if (item?.Recipe == null)
		{
			return null;
		}
		return new LookupItem(item.Recipe.Name, item.Recipe.DisplayName);
	}

	private void OnComponentRecipeChanged(Item item, LookupItem? selectedRecipe)
	{
		if (item != null && selectedRecipe != null && FactoryCatalog != null)
		{
			// Find and assign the selected recipe to the item
			Recipe? recipe = FactoryCatalog.Recipes.FirstOrDefault(r => r.Name == selectedRecipe.Id);
			if (recipe != null)
			{
				item.Recipe = recipe;
			}
		}
	}

	private void StartAddingExportedPart()
	{
		isAddingExportedPart = true;
		selectedPartToExport = null;
		selectedRecipeToExport = null;
		availableRecipes.Clear();
		exportedQuantity = 1.0;
	}

	private void CancelAddingExportedPart()
	{
		isAddingExportedPart = false;
		selectedPartToExport = null;
		selectedRecipeToExport = null;
		availableRecipes.Clear();
	}

	private void OnExportPartSelected(LookupItem selectedPart)
	{
		selectedPartToExport = selectedPart;
		
		// Load recipes for the selected part
		if (selectedPart != null && FactoryCatalog != null)
		{
			List<Recipe> recipes = SatisfactoryTree.Logic.Calculations.Lookups.GetRecipes(FactoryCatalog, selectedPart.Id);
			availableRecipes = recipes.Select(r => new LookupItem(r.Name, r.DisplayName)).ToList();
			
			// Auto-select the first non-alternative recipe
			Recipe? defaultRecipe = recipes.FirstOrDefault(r => !r.IsAlternate);
			if (defaultRecipe != null)
			{
				selectedRecipeToExport = new LookupItem(defaultRecipe.Name, defaultRecipe.DisplayName);
			}
			else if (recipes.Any())
			{
				// If no non-alternative recipe, select the first one
				Recipe firstRecipe = recipes.First();
				selectedRecipeToExport = new LookupItem(firstRecipe.Name, firstRecipe.DisplayName);
			}
			else
			{
				selectedRecipeToExport = null;
			}
		}
	}

	private void OnExportRecipeSelected(LookupItem selectedRecipe)
	{
		selectedRecipeToExport = selectedRecipe;
	}

	private void OnExportRecipeSelectedFromDropdown(string? recipeId)
	{
		if (!string.IsNullOrEmpty(recipeId) && availableRecipes != null)
		{
			selectedRecipeToExport = availableRecipes.FirstOrDefault(r => r.Id == recipeId);
		}
	}

	private void OnExportedPartRecipeChanged(Item item, string? recipeId)
	{
		if (item != null && !string.IsNullOrEmpty(recipeId) && FactoryCatalog != null)
		{
			Recipe? recipe = FactoryCatalog.Recipes.FirstOrDefault(r => r.Name == recipeId);
			if (recipe != null)
			{
				item.Recipe = recipe;
				// Re-validate ingredients when recipe changes
				PlanService.RefreshPlanCalculations();
			}
		}
	}

	private void OnExportedPartQuantityChanged(Item item, string? quantityStr)
	{
		if (item != null && !string.IsNullOrEmpty(quantityStr) && double.TryParse(quantityStr, out double quantity))
		{
			item.Quantity = quantity;
			// Re-validate component part requirements when quantity changes
			PlanService.RefreshPlanCalculations();
		}
	}

	private void OnComponentPartQuantityChanged(Item item, string? quantityStr)
	{
		if (item != null && !string.IsNullOrEmpty(quantityStr) && double.TryParse(quantityStr, out double quantity))
		{
			item.Quantity = quantity;
			// Recalculate dependent ingredients/part components when quantity changes
			PlanService.RefreshPlanCalculations();
		}
	}

	private void OnComponentRecipeChangedFromDropdown(Item item, string? recipeId)
	{
		if (item != null && !string.IsNullOrEmpty(recipeId) && FactoryCatalog != null && Factory != null)
		{
			Recipe? recipe = FactoryCatalog.Recipes.FirstOrDefault(r => r.Name == recipeId);
			if (recipe != null)
			{
				// Store the recipe override so it persists across recalculations
				Factory.ComponentPartRecipeOverrides[item.Name] = recipe.Name;
				
				item.Recipe = recipe;
				// Re-validate ingredients when recipe changes
				PlanService.RefreshPlanCalculations();
			}
		}
	}

	private async Task RemoveComponentPart(Item componentItem)
	{
		if (Factory == null || componentItem == null) return;
		
		try
		{
			// Remove the component part from the factory's component parts list
			Factory.ComponentParts.Remove(componentItem);
			
			// If this component was auto-added (in ExportedParts but not in UserDefinedExports),
			// remove it from ExportedParts as well so it shows as missing again
			if (Factory.ExportedParts.Any(e => e.Item.Name == componentItem.Name) && 
			    !Factory.UserDefinedExports.Contains(componentItem.Name))
			{
				PlanService.RemoveExportedPartFromFactory(Factory.Id, componentItem.Name);
			}
			
			// Note: We intentionally do NOT call RefreshPlanCalculations() here
			// because it would recalculate and add the component back.
			// The removal persists until the next calculation is triggered
			// by another action (recipe change, quantity change, etc.)
			
			await InvokeAsync(StateHasChanged);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error removing component part: {ex.Message}");
		}
	}

	private async Task AddExportedPart()
	{
		if (Factory != null && selectedPartToExport != null)
		{
			try
			{
				string? recipeName = selectedRecipeToExport?.Id;
				PlanService.AddExportedPartToFactory(Factory.Id, selectedPartToExport.Id, exportedQuantity, recipeName);
				isAddingExportedPart = false;
				selectedPartToExport = null;
				selectedRecipeToExport = null;
				availableRecipes.Clear();
				await InvokeAsync(StateHasChanged);
			}
			catch (Exception ex)
			{
				Console.WriteLine($"Error adding exported part: {ex.Message}");
			}
		}
	}

	private async Task RemoveExportedPart(ExportedItem exportedItem)
	{
		if (Factory == null) return;
		try
		{
			PlanService.RemoveExportedPartFromFactory(Factory.Id, exportedItem.Item.Name);
			await InvokeAsync(StateHasChanged);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error removing exported part: {ex.Message}");
		}
	}

	private async Task AddAllMissingIngredients()
	{
		if (Factory == null) return;
		try
		{
			PlanService.AddAllMissingIngredients(Factory.Id);
			await InvokeAsync(StateHasChanged);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error adding missing ingredients: {ex.Message}");
		}
	}

	private List<string> GetMissingIngredients()
	{
		if (Factory == null) return new List<string>();
		return PlanService.GetMissingIngredients(Factory.Id);
	}

	private bool HasUnresolvedMissingIngredients(Item item)
	{
		if (Factory == null || item == null || !item.HasMissingIngredients)
			return false;

		// Check if any missing ingredients are NOT in ExportedParts
		// If all missing ingredients are in ExportedParts, they're being produced, so the warning can be hidden
		return item.MissingIngredients.Any(missingIngredient =>
			!Factory.ExportedParts.Any(e => e.Item.Name == missingIngredient));
	}

	private bool IsComponentMissingFromExports(Item item)
	{
		if (Factory == null || item == null)
			return false;

		// Check if this component item itself is NOT in ExportedParts
		// This indicates the ingredient needs to be added as an exported part to be produced
		return !Factory.ExportedParts.Any(e => e.Item.Name == item.Name);
	}

	private async Task AddSingleIngredient(Item item)
	{
		if (Factory == null || item == null) return;
		try
		{
			// Add just this single ingredient as a component to be produced
			// This adds it to ExportedParts but NOT to UserDefinedExports, so it won't show in the "Exported parts" UI section
			PlanService.AddMissingIngredientsForItem(Factory.Id, item);
			await InvokeAsync(StateHasChanged);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error adding single ingredient: {ex.Message}");
		}
	}

	private async Task AddSingleIngredientByName(string ingredientName, double quantity, string? recipeName)
	{
		if (Factory == null || string.IsNullOrEmpty(ingredientName)) return;
		try
		{
			// Add the ingredient with the actual quantity needed (not the recipe default)
			PlanService.AddExportedPartToFactory(Factory.Id, ingredientName, quantity, recipeName);
			
			// Remove from UserDefinedExports since this is auto-added
			Factory.UserDefinedExports.Remove(ingredientName);
			
			await InvokeAsync(StateHasChanged);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error adding single ingredient by name: {ex.Message}");
		}
	}

	private bool IsRawResource(Item item)
	{
		if (item == null || FactoryCatalog?.RawResources == null)
			return false;

		// Check if the item's name exists in the RawResources dictionary
		return FactoryCatalog.RawResources.ContainsKey(item.Name);
	}

	private List<Item> GetRawResourceItems()
	{
		List<Item> rawResources = new List<Item>();
		
		if (Factory == null)
			return rawResources;

		// Add raw resources from ComponentParts
		if (Factory.ComponentParts != null)
		{
			rawResources.AddRange(Factory.ComponentParts.Where(item => IsRawResource(item)));
		}

		// Also add raw resources from ExportedParts that are NOT user-defined
		// (these are auto-added missing ingredients that happen to be raw resources)
		if (Factory.ExportedParts != null)
		{
			IEnumerable<Item> autoAddedRawResources = Factory.ExportedParts
				.Where(e => !Factory.UserDefinedExports.Contains(e.Item.Name) && IsRawResource(e.Item))
				.Select(e => e.Item);
			rawResources.AddRange(autoAddedRawResources);
		}

		return rawResources;
	}

	private List<Item> GetNonRawResourceComponents()
	{
		if (Factory?.ComponentParts == null)
			return new List<Item>();

		// Return component parts that are NOT raw resources
		return Factory.ComponentParts.Where(item => !IsRawResource(item)).ToList();
	}

	private double GetTotalPowerConsumption()
	{
		if (Factory?.ComponentParts == null)
			return 0;

		return Factory.ComponentParts.Sum(item => item.BuildingPowerUsage);
	}
}

@if (Factory != null)
{
	<div class="factory-container">
		<h3><input type="text" value="@Factory.Name" class="form-control" /></h3>

		<p><b>Exported parts:</b></p>
		@if (Factory.ExportedParts != null && Factory.ExportedParts.Any(e => Factory.UserDefinedExports.Contains(e.Item.Name)))
		{
			<ul>
				@foreach (ExportedItem item in Factory.ExportedParts.Where(e => Factory.UserDefinedExports.Contains(e.Item.Name)))
				{
					<li class="exported-part-item">
						<div class="exported-part-info">
							<img src="@DisplayService.GetPartImagePath(GetPartDisplayName(item.Item.Name))" alt="@GetPartDisplayName(item.Item.Name)" class="part-image" />
							<strong>@GetPartDisplayName(item.Item.Name)</strong> - 
							<input type="number" value="@item.Item.Quantity" @onchange="@(e => OnExportedPartQuantityChanged(item.Item, e.Value?.ToString()))" class="form-control d-inline-block" style="width: 100px;" min="0" step="0.1" /> per/min
							<br />
							<span class="text-muted small">Recipe: </span>
							@{
								List<LookupItem> exportedRecipes = GetRecipesForPart(item.Item.Name);
								if (exportedRecipes.Any())
								{
									<select class="form-control d-inline-block" style="width: auto;" @onchange="@(e => OnExportedPartRecipeChanged(item.Item, e.Value?.ToString()))">
										@foreach (LookupItem recipe in exportedRecipes)
										{
											<option value="@recipe.Id" selected="@(item.Item.Recipe?.Name == recipe.Id)">@recipe.Name</option>
										}
									</select>
								}
								else
								{
									<span class="text-muted small">No recipes available</span>
								}
							}
						</div>
						<button class="btn btn-sm btn-danger" @onclick="() => RemoveExportedPart(item)">Remove</button>
					</li>
				}
			</ul>
		}
		else
		{
			<p class="text-muted">No exported parts defined.</p>
		}

		@if (!isAddingExportedPart)
		{
			<button class="btn btn-primary me-2" @onclick="StartAddingExportedPart">Add Exported Part</button>
		}
		else
		{
			<div class="add-exported-part-form card p-3 mb-3">
				<h5>Add New Exported Part</h5>
				<div class="add-exported-part-inputs">
					<div class="add-exported-part-field">
						<label>Select Part:</label>
						<TypeaheadDropdown TItem="LookupItem"
										   Items="@FactoryCatalog.PartsLookup"
										   DisplayNameSelector="@(p => p.Name)"
										   IdSelector="@(p => p.Id)"
										   SelectedItem="@selectedPartToExport"
										   SelectedItemChanged="@OnExportPartSelected"
										   Placeholder="Search for parts to export..."
										   CssClass="me-2" />
					</div>
					<div class="add-exported-part-field">
						<label>Select Recipe:</label>
						@if (availableRecipes.Any())
						{
							<select class="form-control" @onchange="@(e => OnExportRecipeSelectedFromDropdown(e.Value?.ToString()))">
								@foreach (LookupItem recipe in availableRecipes)
								{
									<option value="@recipe.Id" selected="@(selectedRecipeToExport?.Id == recipe.Id)">@recipe.Name</option>
								}
							</select>
						}
						else
						{
							<p class="text-muted small">No recipes available for this part</p>
						}
					</div>
					<div class="add-exported-part-field">
						<label>Quantity per/min:</label>
						<input type="number" class="form-control" @bind="exportedQuantity" min="0" step="0.1" />
					</div>
				</div>
				<div class="mt-2">
					<button class="btn btn-success me-2" @onclick="AddExportedPart" disabled="@(selectedPartToExport == null)">Add</button>
					<button class="btn btn-secondary" @onclick="CancelAddingExportedPart">Cancel</button>
				</div>
			</div>
		}

		<p><b>Component parts:</b></p>
		<ul>
			@if (GetNonRawResourceComponents().Any())
			{
				@foreach (Item item in GetNonRawResourceComponents())
				{
					<li>
						@if (IsComponentMissingFromExports(item))
						{
							<div class="alert alert-warning d-flex justify-content-between align-items-center mb-2" style="padding: 0.5rem 0.75rem;">
								<div>
									<i class="fas fa-exclamation-triangle me-2"></i>
									<strong>Missing:</strong> This ingredient is not being produced yet.
								</div>
								<button class="btn btn-sm btn-primary" @onclick="() => AddSingleIngredient(item)">
									<i class="fas fa-plus-circle me-1"></i>Add This Ingredient
								</button>
							</div>
						}
						@if (item.IsRedundant)
						{
							<div class="alert alert-secondary d-flex justify-content-between align-items-center mb-2" style="padding: 0.5rem 0.75rem;">
								<div>
									<i class="fas fa-info-circle me-2"></i>
									<strong>Unused:</strong> This ingredient is no longer needed by the current recipe.
								</div>
								<button class="btn btn-sm btn-danger" @onclick="() => RemoveComponentPart(item)">
									<i class="fas fa-trash me-1"></i>Remove
								</button>
							</div>
						}
						<div class="component-part-row">
							<img src="@DisplayService.GetPartImagePath(GetPartDisplayName(item.Name))" alt="@GetPartDisplayName(item.Name)" class="part-image" />
							<TypeaheadDropdown TItem="LookupItem"
									   Items="@FactoryCatalog.PartsLookup"
									   DisplayNameSelector="@(p => p.Name)"
									   IdSelector="@(p => p.Id)"
									   SelectedItem="@GetCurrentLookup(item)"
									   SelectedItemChanged="@(lookup => { if (lookup != null) item.Name = lookup.Id; })"
									   Placeholder="Search for parts..."
									   CssClass="me-2" />
							<span class="quantity-label">Quantity:</span>
							<input type="number" value="@item.Quantity" @onchange="@(e => OnComponentPartQuantityChanged(item, e.Value?.ToString()))" class="form-control quantity-input" min="0" step="0.1" />
							<span class="ms-2">Recipe:</span>
							@{
								List<LookupItem> componentRecipes = GetRecipesForPart(item.Name);
								if (componentRecipes.Any())
								{
									<select class="form-control d-inline-block ms-2" style="width: auto;" @onchange="@(e => OnComponentRecipeChangedFromDropdown(item, e.Value?.ToString()))">
										@foreach (LookupItem recipe in componentRecipes)
										{
											<option value="@recipe.Id" selected="@(item.Recipe?.Name == recipe.Id)">@recipe.Name</option>
										}
									</select>
								}
								else
								{
									<span class="text-muted small ms-2">No recipes available</span>
								}
							}
							<button class="btn btn-sm btn-danger ms-2" @onclick="() => RemoveComponentPart(item)">
								<i class="fas fa-times"></i>
							</button>
						</div>

						<div class="component-badges">
							@if (item.Ingredients != null)
							{
								@foreach (Item ingredient in item.Ingredients)
								{
									bool isMissing = item.HasMissingIngredients && item.MissingIngredients.Contains(ingredient.Name) && !Factory.ExportedParts.Any(e => e.Item.Name == ingredient.Name);
									
									@if (isMissing)
									{
										<span class="badge badge-red d-inline-flex align-items-center gap-2" title="Missing ingredient - not available as import">
											<span>
												<img src="@DisplayService.GetPartImagePath(GetPartDisplayName(ingredient.Name))" alt="@GetPartDisplayName(ingredient.Name)" class="ingredient-image" />
												<i class="fas fa-exclamation-triangle me-1"></i>
												@GetPartDisplayName(ingredient.Name) @Math.Round(ingredient.Quantity, 1) per/min (Missing)
											</span>
											<button class="btn btn-sm btn-primary py-0 px-1" style="font-size: 0.75rem;" @onclick="() => AddSingleIngredientByName(ingredient.Name, ingredient.Quantity, ingredient.Recipe?.Name)">
												<i class="fas fa-plus-circle"></i>
											</button>
										</span>
									}
									else
									{
										<span class="badge badge-blue">
											<img src="@DisplayService.GetPartImagePath(GetPartDisplayName(ingredient.Name))" alt="@GetPartDisplayName(ingredient.Name)" class="ingredient-image" />
											@GetPartDisplayName(ingredient.Name) @Math.Round(ingredient.Quantity, 1) per/min
										</span>
									}
								}
							}
							<span class="badge badge-yellow">
								@if (!string.IsNullOrEmpty(item.Building) && DisplayService.HasBuildingImage(item.Building))
								{
									<img src="@DisplayService.GetBuildingImagePath(item.Building)" alt="@DisplayService.GetBuildingName(item.Building)" class="building-image" />
								}
								else if (!string.IsNullOrEmpty(item.Building))
								{
									<i class="fas fa-building building-icon" title="@item.Building"></i>
								}
								@DisplayService.GetBuildingName(item.Building) x @Math.Round(item.BuildingQuantity, 2)
							</span>
							<span class="badge badge-grey">
								<i class="fas fa-bolt power-icon" title="Power Usage"></i> @Math.Round(item.BuildingPowerUsage, 1) MW
							</span>
						</div>
					</li>
					<hr>
				}
			}
			else
			{
				<li>No component parts calculated yet.</li>
			}
		</ul>

		<p><b>Imported parts:</b></p>
		<ul>
			@if (Factory.ImportedParts != null && Factory.ImportedParts.Any())
			{
				@foreach (KeyValuePair<int, ImportedItem> item in Factory.ImportedParts)
				{
					<li>
						<img src="@DisplayService.GetPartImagePath(GetPartDisplayName(item.Value.Item.Name))" alt="@GetPartDisplayName(item.Value.Item.Name)" class="part-image" />
						<strong>@GetPartDisplayName(item.Value.Item.Name)</strong> - Quantity: @Math.Round(item.Value.Item.Quantity, 1) - from factory: @item.Value.FactoryName (@Math.Round(item.Value.PartQuantityImported, 1) per/min imported)
					</li>
				}
			}
			else
			{
				<li>No imported parts.</li>
			}
		</ul>

		<p><b>Required resources:</b></p>
		@if (GetRawResourceItems().Any() || GetTotalPowerConsumption() > 0)
		{
			@if (GetRawResourceItems().Any())
			{
				@foreach (Item item in GetRawResourceItems())
				{
					<span class="badge badge-blue">
						<img src="@DisplayService.GetPartImagePath(GetPartDisplayName(item.Name))" alt="@GetPartDisplayName(item.Name)" class="ingredient-image" />
						<span>@GetPartDisplayName(item.Name) @Math.Round(item.Quantity, 1) per/min</span>
					</span>
				}
			}
			@if (GetTotalPowerConsumption() > 0)
			{
				<span class="badge badge-grey">
					<i class="fas fa-bolt power-icon" title="Total Power Usage"></i> @Math.Round(GetTotalPowerConsumption(), 1) MW total
				</span>
			}
		}
		else
		{
			<span class="text-muted">No resources needed.</span>
		}
	</div>
}