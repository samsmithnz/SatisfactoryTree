@using SatisfactoryTree.Logic.Calculations
@using SatisfactoryTree.Logic.Models
@using SatisfactoryTree.Web.Services
@using SatisfactoryTree.Logic.Services
@inject PlanService PlanService
@inject PartLookupService PartLookupService
@implements IDisposable
@using System.Linq

@code {
	[Parameter]
	public Factory2? Factory { get; set; }
	[Parameter]
	public FactoryCatalog FactoryCatalog { get; set; } = new();

	private bool isAddingExportedPart = false;
	private LookupItem? selectedPartToExport = null; // only for the add-export UI
	private double exportedQuantity = 1.0;
	private List<LookupItem> availableRecipes = new(); // recipes for the selected part
	private LookupItem? selectedRecipeToExport = null; // selected recipe for export

	protected override void OnInitialized()
	{
		PlanService.PlanChanged += OnPlanChanged;
	}

	protected override void OnParametersSet()
	{
		// Use PartLookupService to ensure lookup and cache display names
		try
		{
			PartLookupService.EnsurePartsLookup(FactoryCatalog);
			// if (_partsDisplayLookup == null)
			// {
			// 	_partsDisplayLookup = PartLookupService.BuildDisplayLookup(FactoryCatalog);
			// }
		}
		catch (Exception ex)
		{
			Console.WriteLine($"FactoryItems: Failed initializing lookups: {ex.Message}");
		}
	}

	private void OnPlanChanged() => InvokeAsync(StateHasChanged);

	public void Dispose() => PlanService.PlanChanged -= OnPlanChanged;

	private LookupItem? GetCurrentLookup(Item item)
	{
		return PartLookupService.GetCurrentLookup(item, FactoryCatalog);
	}

	private List<LookupItem> GetRecipesForPart(string partName)
	{
		if (FactoryCatalog == null || string.IsNullOrEmpty(partName))
		{
			return new();
		}

		List<Recipe> recipes = SatisfactoryTree.Logic.Calculations.Lookups.GetRecipes(FactoryCatalog, partName);
		return recipes.Select(r => new LookupItem(r.Name, r.DisplayName)).ToList();
	}

	private LookupItem? GetCurrentRecipeLookup(Item item)
	{
		if (item?.Recipe == null)
		{
			return null;
		}
		return new LookupItem(item.Recipe.Name, item.Recipe.DisplayName);
	}

	private void OnComponentRecipeChanged(Item item, LookupItem? selectedRecipe)
	{
		if (item != null && selectedRecipe != null && FactoryCatalog != null)
		{
			// Find and assign the selected recipe to the item
			Recipe? recipe = FactoryCatalog.Recipes.FirstOrDefault(r => r.Name == selectedRecipe.Id);
			if (recipe != null)
			{
				item.Recipe = recipe;
			}
		}
	}

	private void StartAddingExportedPart()
	{
		isAddingExportedPart = true;
		selectedPartToExport = null;
		selectedRecipeToExport = null;
		availableRecipes.Clear();
		exportedQuantity = 1.0;
	}

	private void CancelAddingExportedPart()
	{
		isAddingExportedPart = false;
		selectedPartToExport = null;
		selectedRecipeToExport = null;
		availableRecipes.Clear();
	}

	private void OnExportPartSelected(LookupItem selectedPart)
	{
		selectedPartToExport = selectedPart;

		// Load recipes for the selected part
		if (selectedPart != null && FactoryCatalog != null)
		{
			List<Recipe> recipes = SatisfactoryTree.Logic.Calculations.Lookups.GetRecipes(FactoryCatalog, selectedPart.Id);
			availableRecipes = recipes.Select(r => new LookupItem(r.Name, r.DisplayName)).ToList();

			// Auto-select the first non-alternative recipe
			Recipe? defaultRecipe = recipes.FirstOrDefault(r => !r.IsAlternate);
			if (defaultRecipe != null)
			{
				selectedRecipeToExport = new LookupItem(defaultRecipe.Name, defaultRecipe.DisplayName);
			}
			else if (recipes.Any())
			{
				// If no non-alternative recipe, select the first one
				Recipe firstRecipe = recipes.First();
				selectedRecipeToExport = new LookupItem(firstRecipe.Name, firstRecipe.DisplayName);
			}
			else
			{
				selectedRecipeToExport = null;
			}
		}
	}

	private void OnExportRecipeSelected(LookupItem selectedRecipe)
	{
		selectedRecipeToExport = selectedRecipe;
	}

	private void OnExportRecipeSelectedFromDropdown(string? recipeId)
	{
		if (!string.IsNullOrEmpty(recipeId) && availableRecipes != null)
		{
			selectedRecipeToExport = availableRecipes.FirstOrDefault(r => r.Id == recipeId);
		}
	}

	private void OnPartRecipeChanged(Item item, string? recipeId)
	{
		if (item != null && !string.IsNullOrEmpty(recipeId) && FactoryCatalog != null)
		{
			Recipe? recipe = FactoryCatalog.Recipes.FirstOrDefault(r => r.Name == recipeId);
			if (recipe != null)
			{
				item.Recipe = recipe;
				// Re-validate ingredients when recipe changes
				PlanService.RefreshPlanCalculations();
			}
		}
	}

	private void OnPartQuantityChanged(Item item, string? quantityStr)
	{
		if (item != null && !string.IsNullOrEmpty(quantityStr) && double.TryParse(quantityStr, out double quantity))
		{
			item.Quantity = quantity;
			// Re-validate component part requirements when quantity changes
			PlanService.RefreshPlanCalculations();
		}
	}

	private void OnComponentPartQuantityChanged(Item item, string? quantityStr)
	{
		if (item != null && !string.IsNullOrEmpty(quantityStr) && double.TryParse(quantityStr, out double quantity))
		{
			item.Quantity = quantity;
			// Recalculate dependent ingredients/part components when quantity changes
			PlanService.RefreshPlanCalculations();
		}
	}

	private void OnComponentRecipeChangedFromDropdown(Item item, string? recipeId)
	{
		// if (item != null && !string.IsNullOrEmpty(recipeId) && FactoryCatalog != null && Factory != null)
		// {
		// 	Recipe? recipe = FactoryCatalog.Recipes.FirstOrDefault(r => r.Name == recipeId);
		// 	if (recipe != null)
		// 	{
		// 		// Store the recipe override so it persists across recalculations
		// 		Factory.ComponentPartRecipeOverrides[item.Name] = recipe.Name;

		// 		item.Recipe = recipe;
		// 		// Re-validate ingredients when recipe changes
		// 		PlanService.RefreshPlanCalculations();
		// 	}
		// }
	}

	private async Task RemoveComponentPart(Item componentItem)
	{
		if (Factory == null || componentItem == null)
		{
			return;
		}

		try
		{
			// Remove the component part from the factory's component parts list
			Factory.Ingredients.Remove(componentItem);

			// // If this component was auto-added (in ExportedParts but not in UserDefinedExports),
			// // remove it from ExportedParts as well so it shows as missing again
			// if (Factory.ExportedParts.Any(e => e.Item.Name == componentItem.Name) &&
			// 	!Factory.UserDefinedExports.Contains(componentItem.Name))
			// {
			// 	PlanService.RemoveExportedPartFromFactory(Factory.Id, componentItem.Name);
			// }

			// Note: We intentionally do NOT call RefreshPlanCalculations() here
			// because it would recalculate and add the component back.
			// The removal persists until the next calculation is triggered
			// by another action (recipe change, quantity change, etc.)

			await InvokeAsync(StateHasChanged);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error removing component part: {ex.Message}");
		}
	}

	private async Task AddExportedPart()
	{
		if (Factory != null && selectedPartToExport != null)
		{
			try
			{
				string? recipeName = selectedRecipeToExport?.Id;
				PlanService.AddExportedPartToFactory(Factory.Id, selectedPartToExport.Id, exportedQuantity, recipeName);
				isAddingExportedPart = false;
				selectedPartToExport = null;
				selectedRecipeToExport = null;
				availableRecipes.Clear();
				await InvokeAsync(StateHasChanged);
			}
			catch (Exception ex)
			{
				Console.WriteLine($"Error adding exported part: {ex.Message}");
			}
		}
	}

	private async Task RemoveExportedPart(Item item)
	{
		if (Factory == null)
		{
			return;
		}
		try
		{
			PlanService.RemoveExportedPartFromFactory(Factory.Id, item.Name);
			await InvokeAsync(StateHasChanged);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error removing exported part: {ex.Message}");
		}
	}

	private async Task AddAllMissingIngredients()
	{
		if (Factory == null)
		{
			return;
		}
		try
		{
			PlanService.AddAllMissingIngredients(Factory.Id);
			await InvokeAsync(StateHasChanged);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error adding missing ingredients: {ex.Message}");
		}
	}

	private List<ItemIngredient> GetMissingIngredients()
	{
		if (Factory == null)
		{
			return new List<ItemIngredient>();
		}
		return PlanService.GetMissingIngredients(Factory.Id);
	}

	// private bool HasUnresolvedMissingIngredients(Item item)
	// {
	// 	if (Factory == null || item == null || !item.HasMissingIngredients)
	// 	{
	// 		return false;
	// 	}

	// 	// Check if any missing ingredients are NOT in ExportedParts
	// 	// If all missing ingredients are in ExportedParts, they're being produced, so the warning can be hidden
	// 	return item.MissingIngredients.ToList().Any(missingIngredient =>
	// 		!Factory.ExportedParts.Any(e => e.Item.Name == missingIngredient.Name));
	// }

	// private bool IsComponentMissingFromExports(Item item)
	// {
	// 	if (Factory == null || item == null)
	// 	{
	// 		return false;
	// 	}

	// 	// Check if this component item itself is NOT in ExportedParts
	// 	// This indicates the ingredient needs to be added as an exported part to be produced
	// 	return !Factory.ExportedParts.Any(e => e.Item.Name == item.Name);
	// }

	private async Task AddSingleIngredient(Item item)
	{
		if (Factory == null || item == null)
		{
			return;
		}
		try
		{
			// Add just this single ingredient as a component to be produced
			// This adds it to ExportedParts but NOT to UserDefinedExports, so it won't show in the "Exported parts" UI section
			PlanService.AddMissingIngredientsForItem(Factory.Id, item);
			await InvokeAsync(StateHasChanged);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error adding single ingredient: {ex.Message}");
		}
	}

	private async Task AddSingleIngredientByName(string ingredientName, double quantity, string? recipeName)
	{
		if (Factory == null || string.IsNullOrEmpty(ingredientName))
		{
			return;
		}
		try
		{
			// Use aggregation logic inside plan service (ignoring provided quantity; service will compute total across all component parts)
			PlanService.AddSingleMissingIngredientToFactory(Factory.Id, ingredientName);

			//Factory.UserDefinedExports.Remove(ingredientName);

			await InvokeAsync(StateHasChanged);
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error adding single ingredient by name: {ex.Message}");
		}
	}

	private bool IsRawResource(Item item)
	{
		if (item == null || FactoryCatalog?.RawResources == null)
		{
			return false;
		}

		// Check if the item's name exists in the RawResources dictionary
		return FactoryCatalog.RawResources.ContainsKey(item.Name);
	}

	// private List<Item> GetRawResourceItems()
	// {
	// 	List<Item> rawResources = new();

	// 	if (Factory == null)
	// 	{
	// 		return rawResources;
	// 	}

	// 	// Add raw resources from ComponentParts
	// 	if (Factory.ComponentParts != null)
	// 	{
	// 		rawResources.AddRange(Factory.ComponentParts.Where(item => IsRawResource(item)));
	// 	}

	// 	// Also add raw resources from ExportedParts that are NOT user-defined
	// 	// (these are auto-added missing ingredients that happen to be raw resources)
	// 	if (Factory.ExportedParts != null)
	// 	{
	// 		IEnumerable<Item> autoAddedRawResources = Factory.ExportedParts
	// 			.Where(e => !Factory.UserDefinedExports.Contains(e.Item.Name) && IsRawResource(e.Item))
	// 			.Select(e => e.Item);
	// 		rawResources.AddRange(autoAddedRawResources);
	// 	}

	// 	// Aggregate raw resources by name, summing quantities
	// 	// This prevents duplicates when the same raw resource appears in multiple places
	// 	// Note: Only Name and Quantity are relevant for raw resources display,
	// 	// other properties (Ingredients, Building, Recipe, etc.) are not used in this context
	// 	var aggregatedResources = rawResources
	// 		.GroupBy(r => r.Name)
	// 		.Select(g => new Item
	// 		{
	// 			Name = g.Key,
	// 			Quantity = g.Sum(r => r.Quantity)
	// 		})
	// 		.ToList();

	// 	return aggregatedResources;
	// }

	// private List<Item> GetNonRawResourceComponents()
	// {
	// 	if (Factory?.ComponentParts == null)
	// 	{
	// 		return new();
	// 	}

	// 	// Return component parts that are NOT raw resources
	// 	return Factory.ComponentParts.Where(item => !IsRawResource(item)).ToList();
	// }

	// private double GetTotalPowerConsumption()
	// {
	// 	if (Factory?.ComponentParts == null)
	// 	{
	// 		return 0;
	// 	}

	// 	return Factory.ComponentParts.Sum(item => item.BuildingPowerUsage);
	// }
}

@if (Factory != null)
{
	<div class="factory-container">
		<h3><input type="text" value="@Factory.Name" class="form-control" /></h3>

		<p><b>Factory Parts:</b></p>
		@if (Factory.Ingredients != null)
		{
			<ul>
				@foreach (Item item in Factory.Ingredients)
				{
					<li class="exported-part-item">
						<div class="component-part-row">
							<span>
								<img src="@item.ItemImagePath" alt="@item.Name" class="part-image" />
								<strong>@item.Name</strong> -
								<input type="number" value="@item.Quantity" @onchange="@(e => OnPartQuantityChanged(item, e.Value?.ToString()))" class="form-control d-inline-block" style="width: 100px;" min="0" step="0.1" /> per/min
								<span class="badge badge-grey">
									<i class="fa-solid fa-clipboard-list"></i>
								</span>
								@{
									List<LookupItem> partRecipes = GetRecipesForPart(item.Name);
									if (partRecipes.Any())
									{
										<select class="form-control d-inline-block" style="width: auto;" @onchange="@(e => OnPartRecipeChanged(item, e.Value?.ToString()))">
											@foreach (LookupItem recipe in partRecipes)
											{
												<option value="@recipe.Id" selected="@(item.Recipe?.Name == recipe.Id)">@recipe.Name</option>
											}
										</select>
									}
									else
									{
										<span class="text-muted small">No recipes available</span>
									}
								}
								<button class="btn btn-sm btn-danger" @onclick="() => RemoveExportedPart(item)">Remove</button>
							</span>
						</div>
						<div class="component-badges">
							<span>
								@if (item.Ingredients != null)
								{
									@foreach (Item ingredient in item.Ingredients)
									{
										bool isMissing = item.HasMissingIngredients && item.MissingIngredients.Find(i => i.Name == ingredient.Name) != null;
										@* && !Factory.ExportedParts.Any(e => e.Item.Name == ingredient.Name); *@

										@if (isMissing)
										{
											<span class="badge badge-red d-inline-flex align-items-center gap-2" title="Missing ingredient - not available as import">
												<span>
													<img src="@ingredient.ItemImagePath" alt="@ingredient.DisplayName" class="ingredient-image" />
													<i class="fas fa-exclamation-triangle me-1"></i>
													@ingredient.DisplayName, @Math.Round(ingredient.Quantity, 3) per/min (Missing)
												</span>
												<button class="btn btn-sm btn-primary py-0 px-1" style="font-size: 0.75rem;" @onclick="() => AddSingleIngredientByName(ingredient.Name, ingredient.Quantity, ingredient.Recipe?.Name)">
													<i class="fas fa-plus-circle"></i>
												</button>
											</span>
										}
										else
										{
											<span class="badge badge-blue">
												<img src="@ingredient.ItemImagePath" alt="@ingredient.DisplayName" class="ingredient-image" />
												@Lookups.GetPartDisplayName(Factory.FactoryCatalog, ingredient.Name) @Math.Round(ingredient.Quantity, 1) per/min
											</span>
										}
									}
								}
								<span class="badge badge-yellow">
									@if (!string.IsNullOrEmpty(item.Building) && !string.IsNullOrEmpty(item.BuildingImagePath))
									{
										<img src="@item.BuildingImagePath" alt="@item.BuildingDisplayName" class="building-image" />
									}
									else if (!string.IsNullOrEmpty(item.Building))
									{
										<i class="fas fa-building building-icon" title="@item.Building"></i>
									}
									@item.BuildingDisplayName x @Math.Round(item.BuildingQuantity, 2)
								</span>
								<span class="badge badge-grey">
									<i class="fas fa-bolt power-icon" title="Power Usage"></i> @Math.Round(item.BuildingPowerUsage, 1) MW
								</span>
							</span>
						</div>
					</li>
				}
			</ul>
		}
		else
		{
			<p class="text-muted">No exported parts defined.</p>
		}

		@* @if (!isAddingExportedPart)
		{
			<button class="btn btn-primary me-2" @onclick="StartAddingExportedPart">Add Exported Part</button>
		}
		else
		{
			<div class="add-exported-part-form card p-3 mb-3">
				<h5>Add New Exported Part</h5>
				<div class="add-exported-part-inputs">
					<div class="add-exported-part-field">
						<label>Select Part:</label>
						<TypeaheadDropdown TItem="LookupItem"
										   Items="@FactoryCatalog.PartsLookup"
										   DisplayNameSelector="@(p => p.Name)"
										   IdSelector="@(p => p.Id)"
										   SelectedItem="@selectedPartToExport"
										   SelectedItemChanged="@OnExportPartSelected"
										   Placeholder="Search for parts to export..."
										   CssClass="me-2" />
					</div>
					<div class="add-exported-part-field">
						<label>Select Recipe:</label>
						@if (availableRecipes.Any())
						{
							<select class="form-control" @onchange="@(e => OnExportRecipeSelectedFromDropdown(e.Value?.ToString()))">
								@foreach (LookupItem recipe in availableRecipes)
								{
									<option value="@recipe.Id" selected="@(selectedRecipeToExport?.Id == recipe.Id)">@recipe.Name</option>
								}
							</select>
						}
						else
						{
							<p class="text-muted small">No recipes available for this part</p>
						}
					</div>
					<div class="add-exported-part-field">
						<label>Quantity per/min:</label>
						<input type="number" class="form-control" @bind="exportedQuantity" min="0" step="0.1" />
					</div>
				</div>
				<div class="mt-2">
					<button class="btn btn-success me-2" @onclick="AddExportedPart" disabled="@(selectedPartToExport == null)">Add</button>
					<button class="btn btn-secondary" @onclick="CancelAddingExportedPart">Cancel</button>
				</div>
			</div>
		} *@

		@if (false)
		{
			<p><b>Parts:</b></p>
			<ul>
				@if (Factory != null && Factory.Ingredients != null && Factory.Ingredients.Any())
				{
					@foreach (Item item in Factory.Ingredients)
					{
						<li>
							@* @if (IsComponentMissingFromExports(item))
						{
							<div class="alert alert-warning d-flex justify-content-between align-items-center mb-2" style="padding: 0.5rem 0.75rem;">
								<div>
									<i class="fas fa-exclamation-triangle me-2"></i>
									<strong>Missing:</strong> This ingredient is not being produced yet.
								</div>
								<button class="btn btn-sm btn-primary" @onclick="() => AddSingleIngredient(item)">
									<i class="fas fa-plus-circle me-1"></i>Add This Ingredient
								</button>
							</div>
						}
						@if (item.IsRedundant)
						{
							<div class="alert alert-secondary d-flex justify-content-between align-items-center mb-2" style="padding: 0.5rem 0.75rem;">
								<div>
									<i class="fas fa-info-circle me-2"></i>
									<strong>Unused:</strong> This ingredient is no longer needed by the current recipe.
								</div>
								<button class="btn btn-sm btn-danger" @onclick="() => RemoveComponentPart(item)">
									<i class="fas fa-trash me-1"></i>Remove
								</button>
							</div>
						} *@
							<div class="component-part-row">
								@* <img src="@DisplayService.GetPartImagePath(GetPartDisplayName(item.Name))" alt="@GetPartDisplayName(item.Name)" class="part-image" /> *@
								<TypeaheadDropdown TItem="LookupItem"
												   Items="@FactoryCatalog.PartsLookup"
												   DisplayNameSelector="@(p => p.Name)"
												   IdSelector="@(p => p.Id)"
												   SelectedItem="@GetCurrentLookup(item)"
												   SelectedItemChanged="@(lookup => { if (lookup != null) item.Name = lookup.Id; })"
												   Placeholder="Search for parts..."
												   CssClass="me-2" />
								<span class="quantity-label">Quantity:</span>
								<input type="number" value="@item.Quantity" @onchange="@(e => OnComponentPartQuantityChanged(item, e.Value?.ToString()))" class="form-control quantity-input" min="0" step="0.1" />
								<span class="ms-2">Recipe:</span>
								@{
									List<LookupItem> componentRecipes = GetRecipesForPart(item.Name);
									if (componentRecipes.Any())
									{
										<select class="form-control d-inline-block ms-2" style="width: auto;" @onchange="@(e => OnComponentRecipeChangedFromDropdown(item, e.Value?.ToString()))">
											@foreach (LookupItem recipe in componentRecipes)
											{
												<option value="@recipe.Id" selected="@(item.Recipe?.Name == recipe.Id)">@recipe.Name</option>
											}
										</select>
									}
									else
									{
										<span class="text-muted small ms-2">No recipes available</span>
									}
								}
								<button class="btn btn-sm btn-danger ms-2" @onclick="() => RemoveComponentPart(item)">
									<i class="fas fa-times"></i>
								</button>
							</div>

							<div class="component-badges">
								@if (item.Ingredients != null)
								{
									@foreach (Item ingredient in item.Ingredients)
									{
										bool isMissing = item.HasMissingIngredients && item.MissingIngredients.Find(i => i.Name == ingredient.Name) != null;
										@* && !Factory.ExportedParts.Any(e => e.Item.Name == ingredient.Name); *@

										@if (isMissing)
										{
											<span class="badge badge-red d-inline-flex align-items-center gap-2" title="Missing ingredient - not available as import">
												<span>
													@* <img src="@DisplayService.GetPartImagePath(GetPartDisplayName(ingredient.Name))" alt="@GetPartDisplayName(ingredient.Name)" class="ingredient-image" /> *@
													<i class="fas fa-exclamation-triangle me-1"></i>
													@Lookups.GetPartDisplayName(Factory.FactoryCatalog, ingredient.Name), @Math.Round(ingredient.Quantity, 1) per/min (Missing)
												</span>
												<button class="btn btn-sm btn-primary py-0 px-1" style="font-size: 0.75rem;" @onclick="() => AddSingleIngredientByName(ingredient.Name, ingredient.Quantity, ingredient.Recipe?.Name)">
													<i class="fas fa-plus-circle"></i>
												</button>
											</span>
										}
										else
										{
											<span class="badge badge-blue">
												@* <img src="@DisplayService.GetPartImagePath(GetPartDisplayName(ingredient.Name))" alt="@GetPartDisplayName(ingredient.Name)" class="ingredient-image" /> *@
												@Lookups.GetPartDisplayName(Factory.FactoryCatalog, ingredient.Name) @Math.Round(ingredient.Quantity, 1) per/min
											</span>
										}
									}
								}
								<span class="badge badge-yellow">
									@* @if (!string.IsNullOrEmpty(item.Building) && DisplayService.HasBuildingImage(item.Building))
								{
									<img src="@DisplayService.GetBuildingImagePath(item.Building)" alt="@DisplayService.GetBuildingName(item.Building)" class="building-image" />
								}
								else if (!string.IsNullOrEmpty(item.Building))
								{
									<i class="fas fa-building building-icon" title="@item.Building"></i>
								}
								@DisplayService.GetBuildingName(item.Building) x @Math.Round(item.BuildingQuantity, 2)
 *@							</span>
								<span class="badge badge-grey">
									<i class="fas fa-bolt power-icon" title="Power Usage"></i> @Math.Round(item.BuildingPowerUsage, 1) MW
								</span>
							</div>
						</li>
						<hr>
					}
				}
				else
				{
					<li>No component parts calculated yet.</li>
				}
			</ul>
		}

		<p><b>Imported parts:</b></p>
		<ul>
			@if (Factory.ImportedParts != null && Factory.ImportedParts.Any())
			{
		@* 				@foreach (KeyValuePair<int, ImportedItem> item in Factory.ImportedParts)
				{
					<li>
						 <img src="@DisplayService.GetPartImagePath(GetPartDisplayName(item.Value.Item.Name))" alt="@GetPartDisplayName(item.Value.Item.Name)" class="part-image" /> 
						<strong>@GetPartDisplayName(item.Value.Item.Name)</strong> - Quantity: @Math.Round(item.Value.Item.Quantity, 1) - from factory: @item.Value.FactoryName (@Math.Round(item.Value.PartQuantityImported, 1) per/min imported)
					</li>
				}
 *@			}
				else
				{
					<li>No imported parts.</li>
				}
			</ul>

			<p><b>Required resources:</b></p>
			@* @if (GetRawResourceItems().Any() || GetTotalPowerConsumption() > 0)
		{
			@if (GetRawResourceItems().Any())
			{
				@foreach (Item item in GetRawResourceItems())
				{
					<span class="badge badge-blue">
						<img src="@DisplayService.GetPartImagePath(GetPartDisplayName(item.Name))" alt="@GetPartDisplayName(item.Name)" class="ingredient-image" />
						<span>@GetPartDisplayName(item.Name) @Math.Round(item.Quantity, 1) per/min</span>
					</span>
				}
			}
			@if (GetTotalPowerConsumption() > 0)
			{
				<span class="badge badge-grey">
					<i class="fas fa-bolt power-icon" title="Total Power Usage"></i> @Math.Round(GetTotalPowerConsumption(), 1) MW total
				</span>
			}
		}
		else
		{
			<span class="text-muted">No resources needed.</span>
		} *@
		</div>
	}
						